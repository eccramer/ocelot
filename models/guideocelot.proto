syntax = "proto3";
option go_package = "pb";
package models;

import "google/protobuf/empty.proto";
import "google/api/annotations.proto";
import "google/protobuf/timestamp.proto";
import "protoc-gen-swagger/options/annotations.proto";
//import "google/protobuf/wrappers.proto"; //use this when you have to pass a string value

option (grpc.gateway.protoc_gen_swagger.options.openapiv2_swagger) = {
    info: {
        title: "Guide Ocelot Server";
        version: "1.0";
        contact: {
            name: "jessi shank";
            email: "jessishank@level11.com";
        };
    };
    schemes: HTTP;
    schemes: HTTPS;
    consumes: "application/json";
    produces: "application/json";

};
service GuideOcelot {
    rpc GetVCSCreds (google.protobuf.Empty) returns (CredWrapper) {
        option (google.api.http) = {
			get: "/v1/creds/vcs"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Returns all VCS creds that ocelot has and can use for checking out code to build.";
        };
    }

    rpc SetVCSCreds (VCSCreds) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/creds/vcs"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Add a new VCS credential configuration to ocelot for code checkout.";
        };
    }
    rpc UpdateVCSCreds (VCSCreds) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			put: "/v1/creds/vcs"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Update a VCS Credential";
        };
    }
    rpc VCSCredExists (VCSCreds) returns (Exists) {
        option (google.api.http) = {
			get: "/v1/creds/vcs/exists"

		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Check if VCS Credential exists in ocelot already. For knowing whether to call Update or Set";
        };
    }
    rpc CheckConn (google.protobuf.Empty) returns (google.protobuf.Empty) {}

    rpc SetVCSPrivateKey (SSHKeyWrapper) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/creds/vcs/ssh"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Attach the contents of an ssh file to a vcs account. This file will be attached to the build container for cloning the repository.";
        };
    }


    rpc UpdateRepoCreds (RepoCreds) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			put: "/v1/creds/repo"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Update new credential configuration to ocelot for repository integration.";
        };
    }
    rpc RepoCredExists (RepoCreds) returns (Exists) {
        option (google.api.http) = {
			get: "/v1/creds/repo/exists"

		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Check if Repo Credential exists in ocelot already. For knowing whether to call Update or Set";
        };
    }

    rpc UpdateK8SCreds (K8SCreds) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			put: "/v1/creds/k8s"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Update a kubeconfig in ocelot for kubernetes integration.";
        };
    }
    rpc K8SCredExists (K8SCreds) returns (Exists) {
        option (google.api.http) = {
			get: "/v1/creds/k8s/exists"

		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Check if kubeconfig Credential exists in ocelot already. For knowing whether to call Update or Set";
        };
    }

    rpc UpdateSSHCreds (SSHKeyWrapper) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			put: "/v1/creds/ssh"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Update a ssh key for use in build scripts";
        };
    }
    rpc SSHCredExists (SSHKeyWrapper) returns (Exists) {
        option (google.api.http) = {
			get: "/v1/creds/ssh/exists"

		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Check if ssh key file Credential exists in ocelot already. For knowing whether to call Update or Set";
        };
    }
    rpc SetSSHCreds (SSHKeyWrapper) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/creds/ssh"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Add a new ssh key to an account so builds can access them at runtime.";
        };
    }
    rpc GetSSHCreds (google.protobuf.Empty) returns (SSHWrap) {
        option (google.api.http) = {
			get: "/v1/creds/ssh"

		};
    }

    rpc GetRepoCreds (google.protobuf.Empty) returns (RepoCredWrapper) {
        option (google.api.http) = {
			get: "/v1/creds/repo"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Get all known repo integration credentials.";
        };
    }
    rpc SetRepoCreds (RepoCreds) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/creds/repo"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Add new repo credential. password, repoUrl, acctName, username and type are required. type must be nexus|docker.";
        };
    }

    rpc SetK8SCreds (K8SCreds) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/creds/k8s"
			body: "*"
		};
    }
    rpc GetK8SCreds (google.protobuf.Empty) returns (K8SCredsWrapper) {
        option (google.api.http) = {
			get: "/v1/creds/k8s"
		};
    }

    rpc GetAllCreds (google.protobuf.Empty) returns (AllCredsWrapper) {
        option (google.api.http) = {
			get: "/v1/creds"
		};
    }

    rpc BuildRuntime (BuildQuery) returns (Builds) {
        option (google.api.http) = {
			get: "/v1/buildruntime"
		};
    }
    rpc Logs (BuildQuery) returns (stream LineResponse) {}
    rpc LastFewSummaries (RepoAccount) returns (Summaries) {
        option (google.api.http) = {
			get: "/v1/summary"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "will return summaries of the builds for the corresponding repo/account. limit will set how many entries will be returned, will default to 5.";
        };
    }
    rpc GetStatus (StatusQuery) returns (Status) {
        option (google.api.http) = {
			get: "/v1/status"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "GetStatus will return the status of a specific build. Hierarchy for key to lookup with: if hash supplied, will only search by hash. If acctName and repoName are supplied and not hash, \nit will be used as a key for looking up status. If only partialRepo is given in the request, ocelot will attempt to find a match and return the latest build stage details for that.";
        };
    }
    rpc WatchRepo (RepoAccount) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/watch"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "watch will set up a webhook for the given repo/account. all fields required.";
        };
    }
    rpc BuildRepoAndHash (BuildReq) returns (stream LineResponse) {
        option (google.api.http) = {
			post: "/v1/build"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "build will attempt to trigger a build. If the git hash has already been built before, it can be triggered with just acctRepo and hash fields. If it has not been built before, the branch flag is required as well.";
        };
    }
    rpc PollRepo(PollRequest) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/poll"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "poll will set up a polling request. account, repo, cron, and branches are all required fields.";
        };
    }
    rpc DeletePollRepo(PollRequest) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			delete: "/v1/poll"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "delete polling for a repo. account and repo are required.";
        };
    }
    rpc ListPolledRepos(google.protobuf.Empty) returns (Polls) {
        option (google.api.http) = {
			get: "/v1/poll"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "list all repositories that are being polled for changes";
        };
    }
    rpc FindWerker (BuildReq) returns (BuildRuntimeInfo) {
        // find a better place for this?
        option (google.api.http) = {
			get: "/v1/werker/loc"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "get network location of werker that is currrently ";
        };
    }
}

message BuildReq {
    // acctRepo is the ocelot account to which the creds are uploaded and the repository you wish to operate on, in the form account/repo
    string acctRepo = 1;
    // hash is the git hash to trigger.
    string hash = 2;
    // branch is the branch that corresponds to the git hash. if the git hash has never been built by ocelot, this field is required.
    string branch = 3;
}

message AllCredsWrapper {
    // All repository credentials for integrations
    // @inject_tag: yaml:"repoCreds"
    RepoCredWrapper repoCreds = 1;
    // All VCS credentials for building
    // @inject_tag: yaml:"vcsCreds"
    CredWrapper vcsCreds = 3;
}

// just a container for a list of VCSCreds
message CredWrapper {
    repeated VCSCreds vcs = 2;
}

message SSHKeyWrapper {
    // account name to associate ssh key with
    string acctName = 1;
    // the contents of the private key
    bytes privateKey = 2;
    SubCredType subType = 10;
    // identifier is the unique identifier for when an ssh key is not associated with a VCS account.
    string identifier = 11;
}

message SSHWrap {
    repeated SSHKeyWrapper keys = 1;
}

message VCSCreds {
    // clientId is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.
    // @inject_tag: yaml:"clientId"
    string clientId = 1;
    // clientSecret is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.
    // @inject_tag: yaml:"clientSecret"
    string clientSecret = 2;
    // identifier is the name the user calls teh credential set
    string identifier = 8;
    // tokenUrl is the url at which to retrieve the token
    // @inject_tag: yaml:"tokenURL"
    string tokenURL = 3;
    // @inject_tag: yaml:"acctName"
    // acctName is the account to associate the VCSCred with. Must be the account name of the owner of the repository they wish to track (ie level11consulting)
    string acctName = 4;

    // just a string that says whether or not there is an ssh key on file
    // @inject_tag: yaml:"sshFileLoc"
    string sshFileLoc = 6;
    // @inject_tag: yaml:"subType"
    SubCredType subType = 10;
}

// container for list of repo creds
message RepoCredWrapper {
    repeated RepoCreds repo = 3;
}

enum CredType {
    NIL_CT = 0;
    VCS = 1;
    REPO = 2;
    K8S = 3;
    SSH = 5;

}

enum SubCredType {
    NIL_SCT = 0;
    // BITBUCKET is a child of VCS
    BITBUCKET = 1;
    //GITHUB is a child of VCS
    GITHUB = 2;

    //NEXUS is a child of REPO
    NEXUS = 3;
    //MAVEN is a child of REPO
    MAVEN = 4;
    //DOCKER is a child of REPO
    DOCKER = 5;
    //KUBECONF is a child of K8S
    KUBECONF = 6;

    //SSHKEY is a child of SSH
    SSHKEY = 8;
}

message RepoCreds {
    // username of repository
    string username = 1;
    // password of repository
    string password = 2;

    // @inject_tag: yaml:"repoUrl"
    string repoUrl= 6;
    string identifier = 8;
    // @inject_tag: yaml:"acctName"
    // account name (same as from vcs)
    string acctName = 4;
    // @inject_tag: yaml:"subType"
    SubCredType subType = 10;

}

message K8SCreds {
    // account name to associate this credential with
    string acctName = 1;
    // k8scontents is the contents of the kubeconfig file
    string k8sContents = 2;
    // identifier in K8s creds is currently irrelevant, as there can only be one per account
    string identifier = 3;
    // @inject_tag: yaml:"subType"
    SubCredType subType = 5;

}

message K8SCredsWrapper {
    repeated K8SCreds K8SCreds = 2;
}

message StatusQuery {
    //hash is the git hash to get status of
    string hash = 1;
    //acctName is the corresponding account that the hash is attached to
    string acctName = 2;
    //repoName is the corresponding repo name that the hash is attached to
    string repoName = 3;
    //partialRepo is just the first n letters of repo
    string partialRepo = 4;
}

message BuildQuery {
    string hash = 1;
    int64 buildId = 2;
}

message Builds {
    map<string, BuildRuntimeInfo> builds = 1;
}

message BuildRuntimeInfo {
    // done says whether or not the build has completed
    bool   done     = 1;
    // ip is the ip of the werker node that is running the build
    string ip       = 2;
    // grpcPort is the grpc port of the werker running the build
    string grpcPort = 3;
    // hash is the hash
    string hash = 4;
    string acctName = 5;
    string repoName = 6;
    string wsPort   = 7;
}

message LineResponse {
    string outputLine = 1;
}

message RepoAccount {
    string repo = 1;
    string account = 2;
    int32  limit = 3;
}

message Status {
    BuildSummary buildSum = 1;
    repeated StageStatus stages = 2;
    bool isInConsul       = 3;
}

message StageStatus {
    string StageStatus = 1;
    string error = 2;
    int32 status = 3;
    repeated string messages = 4;
    google.protobuf.Timestamp startTime = 5;
    double stageDuration = 6;
}

message BuildSummary {
    string hash = 1;
    bool failed = 2;
    google.protobuf.Timestamp buildTime = 3;
    string account = 4;
    double buildDuration = 5;
    string repo = 6;
    string branch = 7;
    int64 buildId = 8;
    google.protobuf.Timestamp queueTime = 9;
}

message Summaries {
    repeated BuildSummary sums = 1;
}

message PollRequest {
    string account = 1;
    string repo = 2;
    string cron = 4;
    string branches = 5;
    google.protobuf.Timestamp lastCronTime = 6;
    map<string, string> lastHashes = 7;
}

message Polls {
    repeated PollRequest polls = 1;
}

message Exists {
    bool exists = 1;
}