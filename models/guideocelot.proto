syntax = "proto3";
option go_package = "pb";
package models;

import "google/protobuf/empty.proto";
import "google/api/annotations.proto";
import "google/protobuf/timestamp.proto";
import "protoc-gen-swagger/options/annotations.proto";
//import "google/protobuf/wrappers.proto"; //use this when you have to pass a string value

option (grpc.gateway.protoc_gen_swagger.options.openapiv2_swagger) = {
    info: {
        title: "Guide Ocelot Server"
        version: "1.0"
        contact: {
            name: "jessi shank"
            email: "jessishank@level11.com"
        };
    };
    schemes: HTTPS;
    consumes: "application/json"
    produces: "application/json";

};
service GuideOcelot {
    rpc GetVCSCreds (google.protobuf.Empty) returns (CredWrapper) {
        option (google.api.http) = {
			get: "/v1/creds/vcs"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Return all vcs creds"
            description: "Returns all VCS creds that ocelot has and can use for checking out code to build.";
        };
    }
    rpc GetVCSCred(VCSCreds) returns (VCSCreds) {
        option (google.api.http) = {
			get: "/v1/creds/vcs/{acctName}/{identifier}"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Retrieve single VCS cred"
            description: "Returns vcs cred if it exists. subtype is a required query param. \nRefer to modelsVCSCreds for the object fields";
        };
    }
    rpc SetVCSCreds (VCSCreds) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/creds/vcs"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Add VCS Credential"
            description: "Add a new VCS credential configuration to ocelot for code checkout. \nRefer to modelsVCSCreds for the object fields";
        };
    }
    rpc UpdateVCSCreds (VCSCreds) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			put: "/v1/creds/vcs/{acctName}/{identifier}"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update a VCS Credential"
            description: "Endpoint for updating a VCS credential in ocelot. This should only be called if hte credential exists. subType is a required query param \nRefer to modelsVCSCreds for the object fields";
        };
    }
//    account,identifier,cred_sub_type
    rpc VCSCredExists (VCSCreds) returns (Exists) {}
    rpc CheckConn (google.protobuf.Empty) returns (google.protobuf.Empty) {}

    rpc SetVCSPrivateKey (SSHKeyWrapper) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/creds/vcs/{acctName}/{identifier}/ssh"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Attach ssh key to VCS Account"
            description: "Attach the contents of an ssh file to a vcs account. This file will be attached to the build container for cloning the repository. subType is a required query param \nRefer to modelsSSHKeyWrapper for the object fields";
        };
    }

    rpc GetRepoCred(RepoCreds) returns (RepoCreds) {
        option (google.api.http) = {
			get: "/v1/creds/repo/{acctName}/{identifier}"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "return single repo cred"
            description: "Returns repo cred if it exists. subType is a required query param";
        };
    }

    rpc UpdateRepoCreds (RepoCreds) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			put: "/v1/creds/repo/{acctName}/{identifier}"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update repo cred"
            description: "Update new credential configuration to ocelot for repository integration. \nRefer to modelsRepoCreds for the object fields";
        };
    }
    rpc RepoCredExists (RepoCreds) returns (Exists) {}
    rpc GetK8SCred(K8SCreds) returns (K8SCreds) {
        option (google.api.http) = {
			get: "/v1/creds/k8s/{acctName}/{identifier}"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get Kubernetes credential"
            description: "Returns k8s cred if it exists. subtype is a required query param";
        };
    }
    rpc UpdateK8SCreds (K8SCreds) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			put: "/v1/creds/k8s/{acctName}/{identifier}"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update a kubeconfig in ocelot for kubernetes integration. \nRefer to modelsK8SCreds for the object fields";
        };
    }
    rpc K8SCredExists (K8SCreds) returns (Exists) {}

    rpc UpdateSSHCreds (SSHKeyWrapper) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			put: "/v1/creds/ssh/{acctName}/{identifier}"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update ssh key"
            description: "Update a ssh key for use in build scripts. \nRefer to modelsSSHKeyWrapper for the object fields";
        };
    }
    rpc GetSSHCred(SSHKeyWrapper) returns (SSHKeyWrapper) {
        option (google.api.http) = {
			get: "/v1/creds/ssh/{acctName}/{identifier}"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get ssh key"
            description: "Returns ssh cred if it exists. subtype is a required query param";
        };
    }
    rpc SSHCredExists (SSHKeyWrapper) returns (Exists) {    }
    rpc SetSSHCreds (SSHKeyWrapper) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/creds/ssh"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Attach new SSH key to account"
            description: "Add a new ssh key to an account so builds can access them at runtime. \nRefer to modelsSSHKeyWrapper for the object fields";
        };
    }
    rpc GetSSHCreds (google.protobuf.Empty) returns (SSHWrap) {
        option (google.api.http) = {
			get: "/v1/creds/ssh"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get all known SSH integration credentials."
        };
    }

    rpc GetRepoCreds (google.protobuf.Empty) returns (RepoCredWrapper) {
        option (google.api.http) = {
			get: "/v1/creds/repo"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get all known repo integration credentials."
            description: "Get all known repo integration credentials.";
        };
    }
    rpc SetRepoCreds (RepoCreds) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/creds/repo"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Add new Repo cred"
            description: "Add new repo credential. password, repoUrl, acctName, username and type are required. type must be nexus|docker. \nRefer to modelsRepoCreds for the object fields";
        };
    }

    rpc SetK8SCreds (K8SCreds) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/creds/k8s"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Add new Kubernetes Credential"
            description: "Add New kubernetes credential. \nRefer to modelsK8SCreds for the object fields"
        };
    }
    rpc GetK8SCreds (google.protobuf.Empty) returns (K8SCredsWrapper) {
        option (google.api.http) = {
			get: "/v1/creds/k8s"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Retrieve all kubernetes related credentials"
        };
    }

    rpc GetAllCreds (google.protobuf.Empty) returns (AllCredsWrapper) {}


    rpc BuildRuntime (BuildQuery) returns (Builds) {
        option (google.api.http) = {
			get: "/v1/buildruntime"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "get stream of logs for a specific build. can either query by buildId or hash, if buildId is specified it takes precendence over hash. if hash is specified and there are multiple builds with the same hash, it iwll stream the latest one. \nRefer to modelsBuildQuery for object fields"
            summary: "get runtime specification of a specific build";
        };
    }
    rpc Logs (BuildQuery) returns (stream LineResponse) {
        option (google.api.http) = {
			get: "/v1/logs"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "get stream of logs for a specific build. can either query by buildId or hash, if buildId is specified it takes precendence over hash. if hash is specified and there are multiple builds with the same hash, it iwll stream the latest one. \nRefer to modelsBuildQuery for object fields";
        };
    }
    rpc LastFewSummaries (RepoAccount) returns (Summaries) {
        option (google.api.http) = {
			get: "/v1/summary/{account}/{repo}"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "will return summaries of the builds for the corresponding repo/account. limit will set how many entries will be returned";
        };
    }
    rpc GetStatus (StatusQuery) returns (Status) {
        option (google.api.http) = {
			get: "/v1/status"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "GetStatus will return the status of a specific build. Hierarchy for key to lookup with: if hash supplied, will only search by hash. If acctName and repoName are supplied and not hash, \nit will be used as a key for looking up status. If only partialRepo is given in the request, ocelot will attempt to find a match and return the latest build stage details for that.";
        };
    }
    rpc WatchRepo (RepoAccount) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/watch"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "watch will set up a webhook for the given repo/account. all fields required.";
        };
    }
    rpc BuildRepoAndHash (BuildReq) returns (stream LineResponse) {
        option (google.api.http) = {
			post: "/v1/build"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "build will attempt to trigger a build. If the git hash has already been built before, it can be triggered with just acctRepo and hash fields. If it has not been built before, the branch flag is required as well.";
        };
    }
    rpc PollRepo(PollRequest) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/poll"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "poll will set up a polling request. account, repo, cron, and branches are all required fields.";
        };
    }
    rpc DeletePollRepo(PollRequest) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			delete: "/v1/poll/{account}/{repo}"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "delete polling for a repo. account and repo are required.";
        };
    }
    rpc ListPolledRepos(google.protobuf.Empty) returns (Polls) {
        option (google.api.http) = {
			get: "/v1/poll"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "list all repositories that are being polled for changes";
        };
    }
    rpc FindWerker (BuildReq) returns (BuildRuntimeInfo) {
        // find a better place for this?
        option (google.api.http) = {
			get: "/v1/werker/{hash}"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "get network location of werker that is currrently executing a build on the specifed hash";
        };
    }
    rpc GetTrackedRepos(google.protobuf.Empty) returns (AcctRepos) {
        option (google.api.http) = {
			get: "/v1/acctRepos"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "get list of currently tracked account/repos"
        };
    }
}

message BuildReq {
    // acctRepo is the ocelot account to which the creds are uploaded and the repository you wish to operate on, in the form account/repo
    string acctRepo = 1;
    // hash is the git hash to trigger.
    string hash = 2;
    // branch is the branch that corresponds to the git hash. if the git hash has never been built by ocelot, this field is required.
    string branch = 3;
}

message AllCredsWrapper {
    // All repository credentials for integrations
    // @inject_tag: yaml:"repoCreds"
    RepoCredWrapper repoCreds = 1;
    // All VCS credentials for building
    // @inject_tag: yaml:"vcsCreds"
    CredWrapper vcsCreds = 3;
}

// just a container for a list of VCSCreds
message CredWrapper {
    repeated VCSCreds vcs = 2;
}

message SSHKeyWrapper {
    // account name to associate ssh key with
    string acctName = 1;
    // the contents of the private key
    bytes privateKey = 2;
    // There is only one subType taht is valid for SSHKeyWrapper, and it is SSHKEY
    SubCredType subType = 10;
    // identifier is the unique identifier for when an ssh key is not associated with a VCS account.
    string identifier = 11;
}

message SSHWrap {
    repeated SSHKeyWrapper keys = 1;
}

message VCSCreds {
    // clientId is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.
    // @inject_tag: yaml:"clientId"
    string clientId = 1;
    // clientSecret is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.
    // @inject_tag: yaml:"clientSecret"
    string clientSecret = 2;
    // identifier is the name the user calls teh credential set
    string identifier = 8;
    // tokenUrl is the url at which to retrieve the token
    // @inject_tag: yaml:"tokenURL"
    string tokenURL = 3;
    // @inject_tag: yaml:"acctName"
    // acctName is the account to associate the VCSCred with. Must be the account name of the owner of the repository they wish to track (ie level11consulting)
    string acctName = 4;

    // just a string that says whether or not there is an ssh key on file
    // @inject_tag: yaml:"sshFileLoc"
    string sshFileLoc = 6;
    // there is only one subtype that is valid for VCS creds at this time, and it is BITBUCKET
    // @inject_tag: yaml:"subType"
    SubCredType subType = 10;
}

// container for list of repo creds
message RepoCredWrapper {
    repeated RepoCreds repo = 3;
}

enum CredType {
    NIL_CT = 0;
    VCS = 1;
    REPO = 2;
    K8S = 3;
    SSH = 5;

}

enum SubCredType {
    NIL_SCT = 0;
    // BITBUCKET is a child of VCS
    BITBUCKET = 1;
    //GITHUB is a child of VCS
    GITHUB = 2;

    //NEXUS is a child of REPO
    NEXUS = 3;
    //MAVEN is a child of REPO
    MAVEN = 4;
    //DOCKER is a child of REPO
    DOCKER = 5;
    //KUBECONF is a child of K8S
    KUBECONF = 6;

    //SSHKEY is a child of SSH
    SSHKEY = 8;
}

message RepoCreds {
    // username of repository
    string username = 1;
    // password of repository
    string password = 2;

    // @inject_tag: yaml:"repoUrl"
    string repoUrl= 6;
    string identifier = 8;
    // @inject_tag: yaml:"acctName"
    // account name (same as from vcs)
    string acctName = 4;
    // there are two subtypes that are valid for RepoCreds: DOCKER, NEXUS
    // @inject_tag: yaml:"subType"
    SubCredType subType = 10;

}

message K8SCreds {
    // account name to associate this credential with
    string acctName = 1;
    // k8scontents is the contents of the kubeconfig file
    string k8sContents = 2;
    // identifier in K8s creds is currently irrelevant, as there can only be one per account
    string identifier = 3;
    // there is currently only one subtype for k8SCreds, and it is KUBECONF
    // @inject_tag: yaml:"subType"
    SubCredType subType = 5;

}

message K8SCredsWrapper {
    repeated K8SCreds K8SCreds = 2;
}

message StatusQuery {
    //hash is the git hash to get status of
    string hash = 1;
    //acctName is the corresponding account that the hash is attached to
    string acctName = 2;
    //repoName is the corresponding repo name that the hash is attached to
    string repoName = 3;
    //partialRepo is just the first n letters of repo
    string partialRepo = 4;
}

message BuildQuery {
    string hash = 1;
    int64 buildId = 2;
}

message Builds {
    map<string, BuildRuntimeInfo> builds = 1;
}

message BuildRuntimeInfo {
    // done says whether or not the build has completed
    bool   done     = 1;
    // ip is the ip of the werker node that is running the build
    string ip       = 2;
    // grpcPort is the grpc port of the werker running the build
    string grpcPort = 3;
    // hash is the hash
    string hash = 4;
    string acctName = 5;
    string repoName = 6;
    string wsPort   = 7;
}

message LineResponse {
    string outputLine = 1;
}

message RepoAccount {
    string repo = 1;
    string account = 2;
    int32  limit = 3;
}

message Status {
    BuildSummary buildSum = 1;
    repeated StageStatus stages = 2;
    bool isInConsul       = 3;
}

message StageStatus {
    string StageStatus = 1;
    string error = 2;
    int32 status = 3;
    repeated string messages = 4;
    google.protobuf.Timestamp startTime = 5;
    double stageDuration = 6;
}

message BuildSummary {
    string hash = 1;
    bool failed = 2;
    google.protobuf.Timestamp buildTime = 3;
    string account = 4;
    double buildDuration = 5;
    string repo = 6;
    string branch = 7;
    int64 buildId = 8;
    google.protobuf.Timestamp queueTime = 9;
}

message Summaries {
    repeated BuildSummary sums = 1;
}

message PollRequest {
    string account = 1;
    string repo = 2;
    string cron = 4;
    string branches = 5;
    google.protobuf.Timestamp lastCronTime = 6;
    map<string, string> lastHashes = 7;
}

message Polls {
    repeated PollRequest polls = 1;
}

message Exists {
    bool exists = 1;
}

message AcctRepo {
    string account = 1;
    string repo  = 2;
}

message AcctRepos {
    repeated AcctRepo acctRepos = 1;
}