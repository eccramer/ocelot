syntax = "proto3";
option go_package = "pb";
package models;

import "github.com/mwitkow/go-proto-validators/validator.proto";

enum CredType {
    NIL_CT = 0;
    VCS = 1;
    REPO = 2;
    K8S = 3;
    SSH = 5;
    APPLE = 6;

}

enum SubCredType {

    NIL_SCT = 0;
    // BITBUCKET is a child of VCS
    BITBUCKET = 1;
    //GITHUB is a child of VCS
    GITHUB = 2;

    //NEXUS is a child of REPO
    NEXUS = 3;
    //MAVEN is a child of REPO
    MAVEN = 4;
    //DOCKER is a child of REPO
    DOCKER = 5;
    //KUBECONF is a child of K8S
    KUBECONF = 6;

    //SSHKEY is a child of SSH
    SSHKEY = 8;

    //DEVPROFILE is a child of APPLE
    DEVPROFILE = 9;
}

message AllCredsWrapper {
    // All repository credentials for integrations
    // @inject_tag: yaml:"repoCreds"
    RepoCredWrapper repoCreds = 1;
    // All VCS credentials for building
    // @inject_tag: yaml:"vcsCreds"
    CredWrapper vcsCreds = 3;
}

// just a container for a list of VCSCreds
message CredWrapper {
    repeated VCSCreds vcs = 2;
}

message SSHKeyWrapper {
    // account name to associate ssh key with
    string acctName = 1 [(validator.field) = {msg_exists : true}];
    // the contents of the private key
    bytes privateKey = 2 [(validator.field) = {msg_exists : true}];
    SubCredType subType = 10 [(validator.field) = {msg_exists : true}];
    // identifier is the unique identifier for when an ssh key is not associated with a VCS account.
    string identifier = 11 [(validator.field) = {msg_exists : true}];
}

message SSHWrap {
    repeated SSHKeyWrapper keys = 1;
}

message VCSCreds {
    // clientId is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.
    // @inject_tag: yaml:"clientId"
    string clientId = 1;
    // clientSecret is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.
    // @inject_tag: yaml:"clientSecret"
    string clientSecret = 2;
    // identifier is the name the user calls teh credential set
    string identifier = 8 [(validator.field) = {msg_exists : true}];
    // tokenUrl is the url at which to retrieve the token
    // @inject_tag: yaml:"tokenURL"
    string tokenURL = 3;
    // @inject_tag: yaml:"acctName"
    // acctName is the account to associate the VCSCred with. Must be the account name of the owner of the repository they wish to track (ie level11consulting)
    string acctName = 4 [(validator.field) = {msg_exists : true}];

    // just a string that says whether or not there is an ssh key on file
    // @inject_tag: yaml:"sshFileLoc"
    string sshFileLoc = 6;
    // @inject_tag: yaml:"subType"
    SubCredType subType = 10 [(validator.field) = {msg_exists : true}];
}

// container for list of repo creds
message RepoCredWrapper {
    repeated RepoCreds repo = 3;
}


message RepoCreds {
    // username of repository
    string username = 1;
    // password of repository
    string password = 2;

    // @inject_tag: yaml:"repoUrl"
    string repoUrl= 6;
    string identifier = 8 [(validator.field) = {msg_exists : true}];
    // @inject_tag: yaml:"acctName"
    // account name (same as from vcs)
    string acctName = 4 [(validator.field) = {msg_exists : true}];
    // @inject_tag: yaml:"subType"
    SubCredType subType = 10 [(validator.field) = {msg_exists : true}];

}

message K8SCreds {
    // account name to associate this credential with
    string acctName = 1 [(validator.field) = {msg_exists : true}];
    // k8scontents is the contents of the kubeconfig file
    string k8sContents = 2 [(validator.field) = {msg_exists : true}];
    // identifier in K8s creds is currently irrelevant, as there can only be one per account
    string identifier = 3 [(validator.field) = {msg_exists : true}];
    // @inject_tag: yaml:"subType"
    SubCredType subType = 5 [(validator.field) = {msg_exists : true}];

}

message K8SCredsWrapper {
    repeated K8SCreds K8SCreds = 2;
}

message AppleCreds {
    // account name to associate this credential with
    string acctName = 1 [(validator.field) = {msg_exists : true}];
    // identifier in dev profile creds is currently irrelevant, as there can only be one per account
    string identifier = 3 [(validator.field) = {msg_exists : true}];
    // appleSecrets is the zip contents of the apple developer profile that you export in XCode ??
    bytes appleSecrets= 2 [(validator.field) = {msg_exists : true}];
    // @inject_tag: yaml:"subType"
    SubCredType subType = 5 [(validator.field) = {msg_exists : true}];
}

message AppleCredsWrapper {
    repeated AppleCreds appleCreds = 1;
}