syntax = "proto3";
option go_package = "pb";
package models;

import "github.com/mwitkow/go-proto-validators/validator.proto";

enum CredType {
    NIL_CT = 0;
    // VCS Cred type has 2 SubCredTypes: BITBUCKET and GITHUB
    VCS = 1;
    // REPO has 2 SubCredTypes: NEXUS and DOCKER
    REPO = 2;
    // K8S has 1 SubCredType: KUBECONF
    K8S = 3;
    // SSH has 1 SubCredType: SSHKEY
    SSH = 5;
    // APPLE has 1 SubCredType: DEVPROFILE
    APPLE = 6;

}

enum SubCredType {

    NIL_SCT = 0;
    BITBUCKET = 1;
    GITHUB = 2;

    NEXUS = 3;
    MAVEN = 4;
    DOCKER = 5;
    KUBECONF = 6;

    SSHKEY = 8;

    DEVPROFILE = 9;
}

message AllCredsWrapper {
    // All repository credentials for integrations
    // @inject_tag: yaml:"repoCreds"
    RepoCredWrapper repoCreds = 1;
    // All VCS credentials for building
    // @inject_tag: yaml:"vcsCreds"
    CredWrapper vcsCreds = 3;
}

// just a container for a list of VCSCreds
message CredWrapper {
    repeated VCSCreds vcs = 2;
}

message SSHKeyWrapper {
    // account name to associate ssh key with
    string acctName = 1 [(validator.field) = {msg_exists : true}];
    // the contents of the private key
    bytes privateKey = 2 [(validator.field) = {msg_exists : true}];
    // There is only one subType taht is valid for SSHKeyWrapper, and it is SSHKEY
    SubCredType subType = 10 [(validator.field) = {msg_exists : true}];
    // identifier is the unique identifier for when an ssh key is not associated with a VCS account.
    string identifier = 11 [(validator.field) = {msg_exists : true}];
}

message SSHWrap {
    repeated SSHKeyWrapper keys = 1;
}

message VCSCreds {
    // clientId is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.
    // @inject_tag: yaml:"clientId"
    string clientId = 1;
    // clientSecret is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.
    // @inject_tag: yaml:"clientSecret"
    string clientSecret = 2;
    // identifier is the name the user calls teh credential set
    string identifier = 8 [(validator.field) = {msg_exists : true}];
    // tokenUrl is the url at which to retrieve the token
    // @inject_tag: yaml:"tokenURL"
    string tokenURL = 3;
    // @inject_tag: yaml:"acctName"
    // acctName is the account to associate the VCSCred with. Must be the account name of the owner of the repository they wish to track (ie level11consulting)
    string acctName = 4 [(validator.field) = {msg_exists : true}];

    // just a string that says whether or not there is an ssh key on file
    // @inject_tag: yaml:"sshFileLoc"
    string sshFileLoc = 6;
    // there is only one subtype that is valid for VCS creds at this time, and it is BITBUCKET
    // @inject_tag: yaml:"subType"
    SubCredType subType = 10 [(validator.field) = {msg_exists : true}];
}

// container for list of repo creds
message RepoCredWrapper {
    repeated RepoCreds repo = 3;
}


message RepoCreds {
    // username of repository
    string username = 1;
    // password of repository
    string password = 2;

    // @inject_tag: yaml:"repoUrl"
    //repoUrl is the url that is associated with that repository, for example hub.docker.io
    string repoUrl= 6;
    // identifier is the unique identifier that is associated with this acctName
    string identifier = 8 [(validator.field) = {msg_exists : true}];
    // @inject_tag: yaml:"acctName"
    // account name (same as from vcs)
    string acctName = 4 [(validator.field) = {msg_exists : true}];
    // @inject_tag: yaml:"subType"
    // there are two subtypes that are valid for RepoCreds: DOCKER, NEXUS
    SubCredType subType = 10 [(validator.field) = {msg_exists : true}];

}

message K8SCreds {
    // account name to associate this credential with
    string acctName = 1 [(validator.field) = {msg_exists : true}];
    // k8scontents is the contents of the kubeconfig file
    string k8sContents = 2 [(validator.field) = {msg_exists : true}];
    // identifier in K8s creds is currently irrelevant, as there can only be one per account
    string identifier = 3 [(validator.field) = {msg_exists : true}];
    // @inject_tag: yaml:"subType"
    // there is currently only one subtype for k8SCreds, and it is KUBECONF
    SubCredType subType = 5 [(validator.field) = {msg_exists : true}];

}

message K8SCredsWrapper {
    repeated K8SCreds K8SCreds = 2;
}

message AppleCreds {
    // account name to associate this credential with
    string acctName = 1 [(validator.field) = {msg_exists : true}];
    // identifier in dev profile creds is currently irrelevant, as there can only be one per account
    string identifier = 3 [(validator.field) = {msg_exists : true}];
    // appleSecrets is the zip contents of the apple developer profile that you export in XCode ??
    bytes appleSecrets= 2 [(validator.field) = {msg_exists : true}];
    // @inject_tag: yaml:"subType"
    SubCredType subType = 5 [(validator.field) = {msg_exists : true}];
}

message AppleCredsWrapper {
    repeated AppleCreds appleCreds = 1;
}