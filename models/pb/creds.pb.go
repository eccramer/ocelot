// Code generated by protoc-gen-go. DO NOT EDIT.
// source: creds.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CredType int32

const (
	CredType_NIL_CT CredType = 0
	// VCS Cred type has 2 SubCredTypes: BITBUCKET and GITHUB
	CredType_VCS CredType = 1
	// REPO has 2 SubCredTypes: NEXUS and DOCKER
	CredType_REPO CredType = 2
	// K8S has 1 SubCredType: KUBECONF
	CredType_K8S CredType = 3
	// SSH has 1 SubCredType: SSHKEY
	CredType_SSH CredType = 5
	// NOTIFIER has 1 SubCredType: SLACK
	CredType_NOTIFIER CredType = 6
	// APPLE has 1 SubCredType: DEVPROFILE
	CredType_APPLE CredType = 7
)

var CredType_name = map[int32]string{
	0: "NIL_CT",
	1: "VCS",
	2: "REPO",
	3: "K8S",
	5: "SSH",
	6: "NOTIFIER",
	7: "APPLE",
}
var CredType_value = map[string]int32{
	"NIL_CT":   0,
	"VCS":      1,
	"REPO":     2,
	"K8S":      3,
	"SSH":      5,
	"NOTIFIER": 6,
	"APPLE":    7,
}

func (x CredType) String() string {
	return proto.EnumName(CredType_name, int32(x))
}
func (CredType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_creds_69d9d3ee77321fcd, []int{0}
}

type SubCredType int32

const (
	SubCredType_NIL_SCT    SubCredType = 0
	SubCredType_BITBUCKET  SubCredType = 1
	SubCredType_GITHUB     SubCredType = 2
	SubCredType_NEXUS      SubCredType = 3
	SubCredType_MAVEN      SubCredType = 4
	SubCredType_DOCKER     SubCredType = 5
	SubCredType_KUBECONF   SubCredType = 6
	SubCredType_SSHKEY     SubCredType = 8
	SubCredType_SLACK      SubCredType = 9
	SubCredType_DEVPROFILE SubCredType = 10
)

var SubCredType_name = map[int32]string{
	0:  "NIL_SCT",
	1:  "BITBUCKET",
	2:  "GITHUB",
	3:  "NEXUS",
	4:  "MAVEN",
	5:  "DOCKER",
	6:  "KUBECONF",
	8:  "SSHKEY",
	9:  "SLACK",
	10: "DEVPROFILE",
}
var SubCredType_value = map[string]int32{
	"NIL_SCT":    0,
	"BITBUCKET":  1,
	"GITHUB":     2,
	"NEXUS":      3,
	"MAVEN":      4,
	"DOCKER":     5,
	"KUBECONF":   6,
	"SSHKEY":     8,
	"SLACK":      9,
	"DEVPROFILE": 10,
}

func (x SubCredType) String() string {
	return proto.EnumName(SubCredType_name, int32(x))
}
func (SubCredType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_creds_69d9d3ee77321fcd, []int{1}
}

type AllCredsWrapper struct {
	// All repository credentials for integrations
	// @inject_tag: yaml:"repoCreds"
	RepoCreds *RepoCredWrapper `protobuf:"bytes,1,opt,name=repoCreds" json:"repoCreds,omitempty" yaml:"repoCreds"`
	// All VCS credentials for building
	// @inject_tag: yaml:"vcsCreds"
	VcsCreds             *CredWrapper `protobuf:"bytes,3,opt,name=vcsCreds" json:"vcsCreds,omitempty" yaml:"vcsCreds"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *AllCredsWrapper) Reset()         { *m = AllCredsWrapper{} }
func (m *AllCredsWrapper) String() string { return proto.CompactTextString(m) }
func (*AllCredsWrapper) ProtoMessage()    {}
func (*AllCredsWrapper) Descriptor() ([]byte, []int) {
	return fileDescriptor_creds_69d9d3ee77321fcd, []int{0}
}
func (m *AllCredsWrapper) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AllCredsWrapper.Unmarshal(m, b)
}
func (m *AllCredsWrapper) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllCredsWrapper.Marshal(b, m, deterministic)
}
func (dst *AllCredsWrapper) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllCredsWrapper.Merge(dst, src)
}
func (m *AllCredsWrapper) XXX_Size() int {
	return xxx_messageInfo_AllCredsWrapper.Size(m)
}
func (m *AllCredsWrapper) XXX_DiscardUnknown() {
	xxx_messageInfo_AllCredsWrapper.DiscardUnknown(m)
}

var xxx_messageInfo_AllCredsWrapper proto.InternalMessageInfo

func (m *AllCredsWrapper) GetRepoCreds() *RepoCredWrapper {
	if m != nil {
		return m.RepoCreds
	}
	return nil
}

func (m *AllCredsWrapper) GetVcsCreds() *CredWrapper {
	if m != nil {
		return m.VcsCreds
	}
	return nil
}

// just a container for a list of VCSCreds
type CredWrapper struct {
	Vcs                  []*VCSCreds `protobuf:"bytes,2,rep,name=vcs" json:"vcs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *CredWrapper) Reset()         { *m = CredWrapper{} }
func (m *CredWrapper) String() string { return proto.CompactTextString(m) }
func (*CredWrapper) ProtoMessage()    {}
func (*CredWrapper) Descriptor() ([]byte, []int) {
	return fileDescriptor_creds_69d9d3ee77321fcd, []int{1}
}
func (m *CredWrapper) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CredWrapper.Unmarshal(m, b)
}
func (m *CredWrapper) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CredWrapper.Marshal(b, m, deterministic)
}
func (dst *CredWrapper) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredWrapper.Merge(dst, src)
}
func (m *CredWrapper) XXX_Size() int {
	return xxx_messageInfo_CredWrapper.Size(m)
}
func (m *CredWrapper) XXX_DiscardUnknown() {
	xxx_messageInfo_CredWrapper.DiscardUnknown(m)
}

var xxx_messageInfo_CredWrapper proto.InternalMessageInfo

func (m *CredWrapper) GetVcs() []*VCSCreds {
	if m != nil {
		return m.Vcs
	}
	return nil
}

type SSHKeyWrapper struct {
	// account name to associate ssh key with
	AcctName string `protobuf:"bytes,1,opt,name=acctName" json:"acctName,omitempty"`
	// the contents of the private key
	PrivateKey []byte `protobuf:"bytes,2,opt,name=privateKey,proto3" json:"privateKey,omitempty"`
	// There is only one subType taht is valid for SSHKeyWrapper, and it is SSHKEY
	SubType SubCredType `protobuf:"varint,10,opt,name=subType,enum=models.SubCredType" json:"subType,omitempty"`
	// identifier is the unique identifier for when an ssh key is not associated with a VCS account.
	Identifier           string   `protobuf:"bytes,11,opt,name=identifier" json:"identifier,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SSHKeyWrapper) Reset()         { *m = SSHKeyWrapper{} }
func (m *SSHKeyWrapper) String() string { return proto.CompactTextString(m) }
func (*SSHKeyWrapper) ProtoMessage()    {}
func (*SSHKeyWrapper) Descriptor() ([]byte, []int) {
	return fileDescriptor_creds_69d9d3ee77321fcd, []int{2}
}
func (m *SSHKeyWrapper) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SSHKeyWrapper.Unmarshal(m, b)
}
func (m *SSHKeyWrapper) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SSHKeyWrapper.Marshal(b, m, deterministic)
}
func (dst *SSHKeyWrapper) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSHKeyWrapper.Merge(dst, src)
}
func (m *SSHKeyWrapper) XXX_Size() int {
	return xxx_messageInfo_SSHKeyWrapper.Size(m)
}
func (m *SSHKeyWrapper) XXX_DiscardUnknown() {
	xxx_messageInfo_SSHKeyWrapper.DiscardUnknown(m)
}

var xxx_messageInfo_SSHKeyWrapper proto.InternalMessageInfo

func (m *SSHKeyWrapper) GetAcctName() string {
	if m != nil {
		return m.AcctName
	}
	return ""
}

func (m *SSHKeyWrapper) GetPrivateKey() []byte {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *SSHKeyWrapper) GetSubType() SubCredType {
	if m != nil {
		return m.SubType
	}
	return SubCredType_NIL_SCT
}

func (m *SSHKeyWrapper) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

type SSHWrap struct {
	Keys                 []*SSHKeyWrapper `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SSHWrap) Reset()         { *m = SSHWrap{} }
func (m *SSHWrap) String() string { return proto.CompactTextString(m) }
func (*SSHWrap) ProtoMessage()    {}
func (*SSHWrap) Descriptor() ([]byte, []int) {
	return fileDescriptor_creds_69d9d3ee77321fcd, []int{3}
}
func (m *SSHWrap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SSHWrap.Unmarshal(m, b)
}
func (m *SSHWrap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SSHWrap.Marshal(b, m, deterministic)
}
func (dst *SSHWrap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSHWrap.Merge(dst, src)
}
func (m *SSHWrap) XXX_Size() int {
	return xxx_messageInfo_SSHWrap.Size(m)
}
func (m *SSHWrap) XXX_DiscardUnknown() {
	xxx_messageInfo_SSHWrap.DiscardUnknown(m)
}

var xxx_messageInfo_SSHWrap proto.InternalMessageInfo

func (m *SSHWrap) GetKeys() []*SSHKeyWrapper {
	if m != nil {
		return m.Keys
	}
	return nil
}

type VCSCreds struct {
	// clientId is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.
	// @inject_tag: yaml:"clientId"
	ClientId string `protobuf:"bytes,1,opt,name=clientId" json:"clientId,omitempty" yaml:"clientId"`
	// clientSecret is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.
	// @inject_tag: yaml:"clientSecret"
	ClientSecret string `protobuf:"bytes,2,opt,name=clientSecret" json:"clientSecret,omitempty" yaml:"clientSecret"`
	// identifier is the name the user calls teh credential set
	Identifier string `protobuf:"bytes,8,opt,name=identifier" json:"identifier,omitempty"`
	// tokenUrl is the url at which to retrieve the token
	// @inject_tag: yaml:"tokenURL"
	TokenURL string `protobuf:"bytes,3,opt,name=tokenURL" json:"tokenURL,omitempty" yaml:"tokenURL"`
	// @inject_tag: yaml:"acctName"
	// acctName is the account to associate the VCSCred with. Must be the account name of the owner of the repository they wish to track (ie level11consulting)
	AcctName string `protobuf:"bytes,4,opt,name=acctName" json:"acctName,omitempty" yaml:"acctName"`
	// just a string that says whether or not there is an ssh key on file
	// @inject_tag: yaml:"sshFileLoc"
	SshFileLoc string `protobuf:"bytes,6,opt,name=sshFileLoc" json:"sshFileLoc,omitempty" yaml:"sshFileLoc"`
	// there is only one subtype that is valid for VCS creds at this time, and it is BITBUCKET
	// @inject_tag: yaml:"subType"
	SubType              SubCredType `protobuf:"varint,10,opt,name=subType,enum=models.SubCredType" json:"subType,omitempty" yaml:"subType"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *VCSCreds) Reset()         { *m = VCSCreds{} }
func (m *VCSCreds) String() string { return proto.CompactTextString(m) }
func (*VCSCreds) ProtoMessage()    {}
func (*VCSCreds) Descriptor() ([]byte, []int) {
	return fileDescriptor_creds_69d9d3ee77321fcd, []int{4}
}
func (m *VCSCreds) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VCSCreds.Unmarshal(m, b)
}
func (m *VCSCreds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VCSCreds.Marshal(b, m, deterministic)
}
func (dst *VCSCreds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VCSCreds.Merge(dst, src)
}
func (m *VCSCreds) XXX_Size() int {
	return xxx_messageInfo_VCSCreds.Size(m)
}
func (m *VCSCreds) XXX_DiscardUnknown() {
	xxx_messageInfo_VCSCreds.DiscardUnknown(m)
}

var xxx_messageInfo_VCSCreds proto.InternalMessageInfo

func (m *VCSCreds) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *VCSCreds) GetClientSecret() string {
	if m != nil {
		return m.ClientSecret
	}
	return ""
}

func (m *VCSCreds) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

func (m *VCSCreds) GetTokenURL() string {
	if m != nil {
		return m.TokenURL
	}
	return ""
}

func (m *VCSCreds) GetAcctName() string {
	if m != nil {
		return m.AcctName
	}
	return ""
}

func (m *VCSCreds) GetSshFileLoc() string {
	if m != nil {
		return m.SshFileLoc
	}
	return ""
}

func (m *VCSCreds) GetSubType() SubCredType {
	if m != nil {
		return m.SubType
	}
	return SubCredType_NIL_SCT
}

// container for list of repo creds
type RepoCredWrapper struct {
	Repo                 []*RepoCreds `protobuf:"bytes,3,rep,name=repo" json:"repo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *RepoCredWrapper) Reset()         { *m = RepoCredWrapper{} }
func (m *RepoCredWrapper) String() string { return proto.CompactTextString(m) }
func (*RepoCredWrapper) ProtoMessage()    {}
func (*RepoCredWrapper) Descriptor() ([]byte, []int) {
	return fileDescriptor_creds_69d9d3ee77321fcd, []int{5}
}
func (m *RepoCredWrapper) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RepoCredWrapper.Unmarshal(m, b)
}
func (m *RepoCredWrapper) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RepoCredWrapper.Marshal(b, m, deterministic)
}
func (dst *RepoCredWrapper) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepoCredWrapper.Merge(dst, src)
}
func (m *RepoCredWrapper) XXX_Size() int {
	return xxx_messageInfo_RepoCredWrapper.Size(m)
}
func (m *RepoCredWrapper) XXX_DiscardUnknown() {
	xxx_messageInfo_RepoCredWrapper.DiscardUnknown(m)
}

var xxx_messageInfo_RepoCredWrapper proto.InternalMessageInfo

func (m *RepoCredWrapper) GetRepo() []*RepoCreds {
	if m != nil {
		return m.Repo
	}
	return nil
}

type RepoCreds struct {
	// username of repository
	Username string `protobuf:"bytes,1,opt,name=username" json:"username,omitempty"`
	// password of repository
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	// @inject_tag: yaml:"repoUrl"
	// repoUrl is the url that is associated with that repository, for example hub.docker.io
	RepoUrl string `protobuf:"bytes,6,opt,name=repoUrl" json:"repoUrl,omitempty" yaml:"repoUrl"`
	// identifier is the unique identifier that is associated with this acctName
	Identifier string `protobuf:"bytes,8,opt,name=identifier" json:"identifier,omitempty"`
	// @inject_tag: yaml:"acctName"
	// account name (same as from vcs)
	AcctName string `protobuf:"bytes,4,opt,name=acctName" json:"acctName,omitempty" yaml:"acctName"`
	// @inject_tag: yaml:"subType"
	// there are two subtypes that are valid for RepoCreds: DOCKER, NEXUS
	SubType              SubCredType `protobuf:"varint,10,opt,name=subType,enum=models.SubCredType" json:"subType,omitempty" yaml:"subType"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *RepoCreds) Reset()         { *m = RepoCreds{} }
func (m *RepoCreds) String() string { return proto.CompactTextString(m) }
func (*RepoCreds) ProtoMessage()    {}
func (*RepoCreds) Descriptor() ([]byte, []int) {
	return fileDescriptor_creds_69d9d3ee77321fcd, []int{6}
}
func (m *RepoCreds) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RepoCreds.Unmarshal(m, b)
}
func (m *RepoCreds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RepoCreds.Marshal(b, m, deterministic)
}
func (dst *RepoCreds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepoCreds.Merge(dst, src)
}
func (m *RepoCreds) XXX_Size() int {
	return xxx_messageInfo_RepoCreds.Size(m)
}
func (m *RepoCreds) XXX_DiscardUnknown() {
	xxx_messageInfo_RepoCreds.DiscardUnknown(m)
}

var xxx_messageInfo_RepoCreds proto.InternalMessageInfo

func (m *RepoCreds) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *RepoCreds) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *RepoCreds) GetRepoUrl() string {
	if m != nil {
		return m.RepoUrl
	}
	return ""
}

func (m *RepoCreds) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

func (m *RepoCreds) GetAcctName() string {
	if m != nil {
		return m.AcctName
	}
	return ""
}

func (m *RepoCreds) GetSubType() SubCredType {
	if m != nil {
		return m.SubType
	}
	return SubCredType_NIL_SCT
}

type K8SCreds struct {
	// account name to associate this credential with
	AcctName string `protobuf:"bytes,1,opt,name=acctName" json:"acctName,omitempty"`
	// k8scontents is the contents of the kubeconfig file
	K8SContents string `protobuf:"bytes,2,opt,name=k8sContents" json:"k8sContents,omitempty"`
	// identifier in K8s creds, typically the name of the cluster, as expected use case is one config per cluster
	Identifier string `protobuf:"bytes,3,opt,name=identifier" json:"identifier,omitempty"`
	// @inject_tag: yaml:"subType"
	// there is currently only one subtype for k8SCreds, and it is KUBECONF
	SubType              SubCredType `protobuf:"varint,6,opt,name=subType,enum=models.SubCredType" json:"subType,omitempty" yaml:"subType"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *K8SCreds) Reset()         { *m = K8SCreds{} }
func (m *K8SCreds) String() string { return proto.CompactTextString(m) }
func (*K8SCreds) ProtoMessage()    {}
func (*K8SCreds) Descriptor() ([]byte, []int) {
	return fileDescriptor_creds_69d9d3ee77321fcd, []int{7}
}
func (m *K8SCreds) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_K8SCreds.Unmarshal(m, b)
}
func (m *K8SCreds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_K8SCreds.Marshal(b, m, deterministic)
}
func (dst *K8SCreds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SCreds.Merge(dst, src)
}
func (m *K8SCreds) XXX_Size() int {
	return xxx_messageInfo_K8SCreds.Size(m)
}
func (m *K8SCreds) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SCreds.DiscardUnknown(m)
}

var xxx_messageInfo_K8SCreds proto.InternalMessageInfo

func (m *K8SCreds) GetAcctName() string {
	if m != nil {
		return m.AcctName
	}
	return ""
}

func (m *K8SCreds) GetK8SContents() string {
	if m != nil {
		return m.K8SContents
	}
	return ""
}

func (m *K8SCreds) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

func (m *K8SCreds) GetSubType() SubCredType {
	if m != nil {
		return m.SubType
	}
	return SubCredType_NIL_SCT
}

type K8SCredsWrapper struct {
	K8SCreds             []*K8SCreds `protobuf:"bytes,2,rep,name=K8SCreds" json:"K8SCreds,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *K8SCredsWrapper) Reset()         { *m = K8SCredsWrapper{} }
func (m *K8SCredsWrapper) String() string { return proto.CompactTextString(m) }
func (*K8SCredsWrapper) ProtoMessage()    {}
func (*K8SCredsWrapper) Descriptor() ([]byte, []int) {
	return fileDescriptor_creds_69d9d3ee77321fcd, []int{8}
}
func (m *K8SCredsWrapper) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_K8SCredsWrapper.Unmarshal(m, b)
}
func (m *K8SCredsWrapper) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_K8SCredsWrapper.Marshal(b, m, deterministic)
}
func (dst *K8SCredsWrapper) XXX_Merge(src proto.Message) {
	xxx_messageInfo_K8SCredsWrapper.Merge(dst, src)
}
func (m *K8SCredsWrapper) XXX_Size() int {
	return xxx_messageInfo_K8SCredsWrapper.Size(m)
}
func (m *K8SCredsWrapper) XXX_DiscardUnknown() {
	xxx_messageInfo_K8SCredsWrapper.DiscardUnknown(m)
}

var xxx_messageInfo_K8SCredsWrapper proto.InternalMessageInfo

func (m *K8SCredsWrapper) GetK8SCreds() []*K8SCreds {
	if m != nil {
		return m.K8SCreds
	}
	return nil
}

type AppleCreds struct {
	// account name to associate this credential with
	AcctName string `protobuf:"bytes,1,opt,name=acctName" json:"acctName,omitempty"`
	// identifier in dev profile creds is currently irrelevant, as there can only be one per account
	Identifier string `protobuf:"bytes,3,opt,name=identifier" json:"identifier,omitempty"`
	// appleSecrets is the zip contents of the apple developer profile that you export in XCode ??
	AppleSecrets []byte `protobuf:"bytes,2,opt,name=appleSecrets,proto3" json:"appleSecrets,omitempty"`
	// appleSecretsPassword is the password you set when you export the developer profile
	AppleSecretsPassword string `protobuf:"bytes,6,opt,name=appleSecretsPassword" json:"appleSecretsPassword,omitempty"`
	// @inject_tag: yaml:"subType"
	SubType              SubCredType `protobuf:"varint,5,opt,name=subType,enum=models.SubCredType" json:"subType,omitempty" yaml:"subType"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *AppleCreds) Reset()         { *m = AppleCreds{} }
func (m *AppleCreds) String() string { return proto.CompactTextString(m) }
func (*AppleCreds) ProtoMessage()    {}
func (*AppleCreds) Descriptor() ([]byte, []int) {
	return fileDescriptor_creds_69d9d3ee77321fcd, []int{9}
}
func (m *AppleCreds) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AppleCreds.Unmarshal(m, b)
}
func (m *AppleCreds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AppleCreds.Marshal(b, m, deterministic)
}
func (dst *AppleCreds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppleCreds.Merge(dst, src)
}
func (m *AppleCreds) XXX_Size() int {
	return xxx_messageInfo_AppleCreds.Size(m)
}
func (m *AppleCreds) XXX_DiscardUnknown() {
	xxx_messageInfo_AppleCreds.DiscardUnknown(m)
}

var xxx_messageInfo_AppleCreds proto.InternalMessageInfo

func (m *AppleCreds) GetAcctName() string {
	if m != nil {
		return m.AcctName
	}
	return ""
}

func (m *AppleCreds) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

func (m *AppleCreds) GetAppleSecrets() []byte {
	if m != nil {
		return m.AppleSecrets
	}
	return nil
}

func (m *AppleCreds) GetAppleSecretsPassword() string {
	if m != nil {
		return m.AppleSecretsPassword
	}
	return ""
}

func (m *AppleCreds) GetSubType() SubCredType {
	if m != nil {
		return m.SubType
	}
	return SubCredType_NIL_SCT
}

type AppleCredsWrapper struct {
	AppleCreds           []*AppleCreds `protobuf:"bytes,1,rep,name=appleCreds" json:"appleCreds,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *AppleCredsWrapper) Reset()         { *m = AppleCredsWrapper{} }
func (m *AppleCredsWrapper) String() string { return proto.CompactTextString(m) }
func (*AppleCredsWrapper) ProtoMessage()    {}
func (*AppleCredsWrapper) Descriptor() ([]byte, []int) {
	return fileDescriptor_creds_69d9d3ee77321fcd, []int{10}
}
func (m *AppleCredsWrapper) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AppleCredsWrapper.Unmarshal(m, b)
}
func (m *AppleCredsWrapper) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AppleCredsWrapper.Marshal(b, m, deterministic)
}
func (dst *AppleCredsWrapper) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppleCredsWrapper.Merge(dst, src)
}
func (m *AppleCredsWrapper) XXX_Size() int {
	return xxx_messageInfo_AppleCredsWrapper.Size(m)
}
func (m *AppleCredsWrapper) XXX_DiscardUnknown() {
	xxx_messageInfo_AppleCredsWrapper.DiscardUnknown(m)
}

var xxx_messageInfo_AppleCredsWrapper proto.InternalMessageInfo

func (m *AppleCredsWrapper) GetAppleCreds() []*AppleCreds {
	if m != nil {
		return m.AppleCreds
	}
	return nil
}

type NotifyWrap struct {
	Creds                []*NotifyCreds `protobuf:"bytes,1,rep,name=creds" json:"creds,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NotifyWrap) Reset()         { *m = NotifyWrap{} }
func (m *NotifyWrap) String() string { return proto.CompactTextString(m) }
func (*NotifyWrap) ProtoMessage()    {}
func (*NotifyWrap) Descriptor() ([]byte, []int) {
	return fileDescriptor_creds_69d9d3ee77321fcd, []int{11}
}
func (m *NotifyWrap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NotifyWrap.Unmarshal(m, b)
}
func (m *NotifyWrap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NotifyWrap.Marshal(b, m, deterministic)
}
func (dst *NotifyWrap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotifyWrap.Merge(dst, src)
}
func (m *NotifyWrap) XXX_Size() int {
	return xxx_messageInfo_NotifyWrap.Size(m)
}
func (m *NotifyWrap) XXX_DiscardUnknown() {
	xxx_messageInfo_NotifyWrap.DiscardUnknown(m)
}

var xxx_messageInfo_NotifyWrap proto.InternalMessageInfo

func (m *NotifyWrap) GetCreds() []*NotifyCreds {
	if m != nil {
		return m.Creds
	}
	return nil
}

type NotifyCreds struct {
	// account name to associate integration cred with
	AcctName string `protobuf:"bytes,1,opt,name=acctName" json:"acctName,omitempty"`
	// There is currently only one subType that is valid for Integrations, and it is SLACK
	SubType SubCredType `protobuf:"varint,2,opt,name=subType,enum=models.SubCredType" json:"subType,omitempty"`
	// identifier is the unique identifier for the integration
	Identifier string `protobuf:"bytes,3,opt,name=identifier" json:"identifier,omitempty"`
	// clientSecret is the secret associated with the integration cred
	ClientSecret         string   `protobuf:"bytes,4,opt,name=clientSecret" json:"clientSecret,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NotifyCreds) Reset()         { *m = NotifyCreds{} }
func (m *NotifyCreds) String() string { return proto.CompactTextString(m) }
func (*NotifyCreds) ProtoMessage()    {}
func (*NotifyCreds) Descriptor() ([]byte, []int) {
	return fileDescriptor_creds_69d9d3ee77321fcd, []int{12}
}
func (m *NotifyCreds) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NotifyCreds.Unmarshal(m, b)
}
func (m *NotifyCreds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NotifyCreds.Marshal(b, m, deterministic)
}
func (dst *NotifyCreds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotifyCreds.Merge(dst, src)
}
func (m *NotifyCreds) XXX_Size() int {
	return xxx_messageInfo_NotifyCreds.Size(m)
}
func (m *NotifyCreds) XXX_DiscardUnknown() {
	xxx_messageInfo_NotifyCreds.DiscardUnknown(m)
}

var xxx_messageInfo_NotifyCreds proto.InternalMessageInfo

func (m *NotifyCreds) GetAcctName() string {
	if m != nil {
		return m.AcctName
	}
	return ""
}

func (m *NotifyCreds) GetSubType() SubCredType {
	if m != nil {
		return m.SubType
	}
	return SubCredType_NIL_SCT
}

func (m *NotifyCreds) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

func (m *NotifyCreds) GetClientSecret() string {
	if m != nil {
		return m.ClientSecret
	}
	return ""
}

func init() {
	proto.RegisterType((*AllCredsWrapper)(nil), "models.AllCredsWrapper")
	proto.RegisterType((*CredWrapper)(nil), "models.CredWrapper")
	proto.RegisterType((*SSHKeyWrapper)(nil), "models.SSHKeyWrapper")
	proto.RegisterType((*SSHWrap)(nil), "models.SSHWrap")
	proto.RegisterType((*VCSCreds)(nil), "models.VCSCreds")
	proto.RegisterType((*RepoCredWrapper)(nil), "models.RepoCredWrapper")
	proto.RegisterType((*RepoCreds)(nil), "models.RepoCreds")
	proto.RegisterType((*K8SCreds)(nil), "models.K8SCreds")
	proto.RegisterType((*K8SCredsWrapper)(nil), "models.K8SCredsWrapper")
	proto.RegisterType((*AppleCreds)(nil), "models.AppleCreds")
	proto.RegisterType((*AppleCredsWrapper)(nil), "models.AppleCredsWrapper")
	proto.RegisterType((*NotifyWrap)(nil), "models.NotifyWrap")
	proto.RegisterType((*NotifyCreds)(nil), "models.NotifyCreds")
	proto.RegisterEnum("models.CredType", CredType_name, CredType_value)
	proto.RegisterEnum("models.SubCredType", SubCredType_name, SubCredType_value)
}

func init() { proto.RegisterFile("creds.proto", fileDescriptor_creds_69d9d3ee77321fcd) }

var fileDescriptor_creds_69d9d3ee77321fcd = []byte{
	// 751 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xdd, 0x6e, 0xd3, 0x4c,
	0x10, 0xfd, 0x9c, 0x5f, 0x7b, 0x9c, 0xb6, 0xdb, 0xfd, 0x40, 0x58, 0x5c, 0xa0, 0xc8, 0x12, 0x52,
	0xa8, 0xa0, 0x88, 0x00, 0x22, 0x77, 0x28, 0x71, 0x9d, 0x26, 0x72, 0x48, 0xa2, 0x75, 0x12, 0x7e,
	0x6e, 0x50, 0xe2, 0x6c, 0x45, 0xd4, 0x34, 0xb6, 0x6c, 0xb7, 0x28, 0xef, 0xc0, 0x3d, 0x12, 0xe2,
	0x81, 0xb8, 0xe3, 0x59, 0x78, 0x03, 0xb4, 0xb6, 0xd7, 0xde, 0xa4, 0x2d, 0x6d, 0xef, 0x32, 0x67,
	0xce, 0xcc, 0x9e, 0x39, 0xb3, 0xde, 0x80, 0xea, 0xf8, 0x74, 0x1e, 0x1c, 0x7a, 0xbe, 0x1b, 0xba,
	0xb8, 0x74, 0xe6, 0xce, 0xe9, 0x32, 0xd0, 0xd7, 0xb0, 0xd7, 0x5c, 0x2e, 0x0d, 0x96, 0x79, 0xef,
	0x4f, 0x3d, 0x8f, 0xfa, 0xf8, 0x35, 0x28, 0x3e, 0xf5, 0xdc, 0x08, 0xd3, 0xa4, 0xaa, 0x54, 0x53,
	0xeb, 0x0f, 0x0e, 0x63, 0xfa, 0x21, 0x49, 0x12, 0x09, 0x97, 0x64, 0x4c, 0xfc, 0x1c, 0xe4, 0x0b,
	0x27, 0x88, 0xab, 0xf2, 0x51, 0xd5, 0xff, 0xbc, 0x4a, 0xac, 0x48, 0x49, 0xfa, 0x0b, 0x50, 0x85,
	0x04, 0xd6, 0x21, 0x7f, 0xe1, 0x04, 0x5a, 0xae, 0x9a, 0xaf, 0xa9, 0x75, 0xc4, 0x4b, 0x27, 0x86,
	0x1d, 0xb1, 0x09, 0x4b, 0xea, 0x3f, 0x24, 0xd8, 0xb1, 0xed, 0x8e, 0x45, 0xd7, 0xbc, 0xea, 0x21,
	0xc8, 0x53, 0xc7, 0x09, 0xfb, 0xd3, 0x33, 0x1a, 0x69, 0x55, 0x48, 0x1a, 0xe3, 0x47, 0x00, 0x9e,
	0xbf, 0xb8, 0x98, 0x86, 0xd4, 0xa2, 0x6b, 0x2d, 0x57, 0x95, 0x6a, 0x15, 0x22, 0x20, 0xf8, 0x19,
	0x94, 0x83, 0xf3, 0xd9, 0x68, 0xed, 0x51, 0x0d, 0xaa, 0x52, 0x6d, 0x37, 0x13, 0x6c, 0x9f, 0xcf,
	0xd8, 0xa9, 0x2c, 0x45, 0x38, 0x87, 0xb5, 0x5b, 0xcc, 0xe9, 0x2a, 0x5c, 0x9c, 0x2c, 0xa8, 0xaf,
	0xa9, 0xd1, 0x61, 0x02, 0xa2, 0xbf, 0x82, 0xb2, 0x6d, 0x77, 0x98, 0x30, 0xfc, 0x04, 0x0a, 0xa7,
	0x74, 0xcd, 0xdc, 0x63, 0xc3, 0xdc, 0x4f, 0xdb, 0x8a, 0xd2, 0x49, 0x44, 0xd1, 0xff, 0x48, 0x20,
	0xf3, 0x21, 0xd9, 0x34, 0xce, 0x72, 0x41, 0x57, 0x61, 0x77, 0xce, 0xa7, 0xe1, 0x31, 0xd6, 0xa1,
	0x12, 0xff, 0xb6, 0xa9, 0xe3, 0xd3, 0x30, 0x9a, 0x47, 0x21, 0x1b, 0xd8, 0x96, 0x44, 0x79, 0x5b,
	0x22, 0xeb, 0x1f, 0xba, 0xa7, 0x74, 0x35, 0x26, 0xbd, 0x68, 0x47, 0x0a, 0x49, 0xe3, 0x0d, 0x27,
	0x0b, 0x97, 0x9d, 0x0c, 0x82, 0x2f, 0xed, 0xc5, 0x92, 0xf6, 0x5c, 0x47, 0x2b, 0xc5, 0x7d, 0x33,
	0xe4, 0x8e, 0x4e, 0xea, 0x0d, 0xd8, 0xdb, 0xba, 0x48, 0xf8, 0x31, 0x14, 0xd8, 0x55, 0xd2, 0xf2,
	0x91, 0x63, 0xfb, 0xdb, 0xf7, 0x2d, 0x20, 0x51, 0x5a, 0xff, 0x25, 0x81, 0x92, 0x62, 0x4c, 0xf2,
	0x79, 0x40, 0xfd, 0x95, 0xb0, 0x7c, 0x1e, 0xb3, 0x9c, 0x37, 0x0d, 0x82, 0xaf, 0xae, 0x3f, 0x4f,
	0xac, 0x4a, 0x63, 0xac, 0x41, 0x99, 0x75, 0x1b, 0xfb, 0xcb, 0x64, 0x16, 0x1e, 0xde, 0xc6, 0xc0,
	0x6b, 0x4d, 0xba, 0xa3, 0x09, 0xdf, 0x25, 0x90, 0xad, 0x46, 0xb6, 0xf8, 0x6b, 0xaf, 0x71, 0x15,
	0xd4, 0xd3, 0x46, 0x60, 0xb8, 0xab, 0x90, 0xae, 0xc2, 0x20, 0x19, 0x46, 0x84, 0xb6, 0x54, 0xe7,
	0x2f, 0xa9, 0x16, 0x94, 0x95, 0x6e, 0xa1, 0xec, 0x2d, 0xec, 0x71, 0x61, 0x7c, 0x3d, 0x4f, 0x33,
	0xad, 0xdb, 0x5f, 0x28, 0xc7, 0x49, 0xca, 0xd0, 0x7f, 0x4b, 0x00, 0x4d, 0xcf, 0x5b, 0xd2, 0x9b,
	0x87, 0xbb, 0x49, 0xba, 0x0e, 0x95, 0x29, 0xeb, 0x14, 0x5f, 0xf0, 0x20, 0xf9, 0x8a, 0x37, 0x30,
	0x5c, 0x87, 0x7b, 0x62, 0x3c, 0xe4, 0x6b, 0x8f, 0x77, 0x7b, 0x65, 0x4e, 0xb4, 0xa4, 0x78, 0x0b,
	0x4b, 0x8e, 0x61, 0x3f, 0x1b, 0x88, 0x9b, 0x52, 0x07, 0x98, 0xa6, 0x60, 0xf2, 0xad, 0x63, 0xde,
	0x26, 0xa3, 0x13, 0x81, 0xa5, 0xbf, 0x01, 0xe8, 0xbb, 0xe1, 0xe2, 0x64, 0x9d, 0xbc, 0x13, 0x45,
	0x47, 0x28, 0x4e, 0x35, 0xc4, 0x94, 0xb8, 0x3a, 0x66, 0xe8, 0x3f, 0x25, 0x50, 0x05, 0xf8, 0x9f,
	0xa6, 0x0a, 0xc3, 0xe5, 0xee, 0xfc, 0xb0, 0x5d, 0xb9, 0x83, 0x8d, 0x97, 0xa7, 0x70, 0xf9, 0xe5,
	0x39, 0x18, 0x81, 0xcc, 0x1b, 0x63, 0x80, 0x52, 0xbf, 0xdb, 0xfb, 0x6c, 0x8c, 0xd0, 0x7f, 0xb8,
	0x0c, 0xf9, 0x89, 0x61, 0x23, 0x09, 0xcb, 0x50, 0x20, 0xe6, 0x70, 0x80, 0x72, 0x0c, 0xb2, 0x1a,
	0x36, 0xca, 0xb3, 0x1f, 0xb6, 0xdd, 0x41, 0x45, 0x5c, 0x01, 0xb9, 0x3f, 0x18, 0x75, 0xdb, 0x5d,
	0x93, 0xa0, 0x12, 0x56, 0xa0, 0xd8, 0x1c, 0x0e, 0x7b, 0x26, 0x2a, 0x1f, 0x7c, 0x93, 0x40, 0x15,
	0x24, 0x63, 0x15, 0xca, 0xac, 0xb3, 0x1d, 0xb5, 0xde, 0x01, 0xa5, 0xd5, 0x1d, 0xb5, 0xc6, 0x86,
	0x65, 0x8e, 0x90, 0xc4, 0x4e, 0x3d, 0xee, 0x8e, 0x3a, 0xe3, 0x16, 0xca, 0xb1, 0x16, 0x7d, 0xf3,
	0xc3, 0x98, 0x1d, 0xa2, 0x40, 0xf1, 0x5d, 0x73, 0x62, 0xf6, 0x51, 0x81, 0x31, 0x8e, 0x06, 0x86,
	0x65, 0x92, 0xf8, 0x48, 0x6b, 0xdc, 0x32, 0x8d, 0x41, 0xbf, 0x8d, 0x4a, 0x2c, 0xc3, 0xde, 0x66,
	0xf3, 0x23, 0x92, 0x59, 0x81, 0xdd, 0x6b, 0x1a, 0x16, 0x52, 0xf0, 0x2e, 0xc0, 0x91, 0x39, 0x19,
	0x92, 0x41, 0xbb, 0xdb, 0x33, 0x11, 0xb4, 0x0a, 0x9f, 0x72, 0xde, 0x6c, 0x56, 0x8a, 0xfe, 0x41,
	0x5f, 0xfe, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x0d, 0x0c, 0x04, 0x0b, 0x50, 0x07, 0x00, 0x00,
}
