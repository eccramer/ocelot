package models

import (
	"database/sql/driver"
	"encoding/json"
	"errors"
	"time"
)

type BuildSummary struct {
	Hash 		  string		`json:"hash,omitempty"`
	Failed 		  bool			`json:"failed,omitempty"`
	BuildTime 	  time.Time		`json:"buildTime,omitempty"`
	Account   	  string		`json:"account,omitempty"`
	BuildDuration float64		`json:"buildDuration,omitempty"`
	Repo 	      string		`json:"repo,omitempty"`
	Branch 		  string		`json:"branch,omitempty"`
	BuildId 	  int64    // generated by postgres
}

// this validates the build summary with the minimum info required
func (s *BuildSummary) Validate() (errors []string) {
	if s.Hash == "" {
		errors = append(errors,"hash required")
	}
	if s.Account == "" {
		errors = append(errors, "account required")
	}
	if s.Repo == "" {
		errors = append(errors, "repo required")
	}
	if s.Branch == "" {
		errors = append(errors, "branch required")
	}
	return
}

type BuildOutput struct {
	BuildId  int64   `json:"buildId,omitempty"`
	Output   string  `json:"output,omitempty"`
	OutputId int64 	 `json:"outputId,omitempty"`	// generated by postgres
}

func (o *BuildOutput) Validate() error {
	if o.Output == "" {
		return NewErrInvalid("no build output to store")
	}
	if o.BuildId == 0 {
		return NewErrInvalid("build id required")
	}
	return nil
}

type BuildFailureReason struct {
	BuildId 	    int64 // generated by postgres
	FailureReasons  *FailureReasons // todo: figure out what FailureReasons looks like
	FailureReasonId int64 // generated by postgres
}


type FailureReasons struct {
	Stage    string			`json:"stage,omitempty"`
	Status   int32			`json:"status,omitempty"`
	Error    string 			`json:"error,omitempty"`
	Messages []string	   		`json:"messages,omitempty"`
	Additional FailureData		`json:"additional,omitempty"`
}

func (f FailureReasons) Value() (driver.Value, error) {
	j, err := json.Marshal(f)
	return j, err
}

func (f *FailureReasons) Scan(src interface{}) error {
	source, ok := src.([]byte)
	if !ok {
		return errors.New("unable to cast source to []byte")
	}
	if err := json.Unmarshal(source, f); err != nil {
		return err
	}
	return nil
}

func (r *BuildFailureReason) Validate() error {
	if r.FailureReasons == new(FailureReasons) {
		return NewErrInvalid("no failure reasons to store")
	}
	if r.BuildId == 0 {
		return NewErrInvalid("build id required")
	}
	return nil
}

type BuildDocket struct {
	Summary       *BuildSummary
	Output        *BuildOutput
	FailureReason *BuildFailureReason
}

// errors for validation
type ErrInvalid struct {
	message string
}
func NewErrInvalid(message string) *ErrInvalid {
	return &ErrInvalid{
		message: message,
	}
}
func (e *ErrInvalid) Error() string {
	return e.message
}

