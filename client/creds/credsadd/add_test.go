package credsadd

import (
	"bitbucket.org/level11consulting/ocelot/admin/models"
	"bitbucket.org/level11consulting/ocelot/client/commandhelper"
	"context"
	"flag"
	"github.com/golang/protobuf/ptypes/empty"
	"github.com/mitchellh/cli"
	"testing"
)

// testNew will return the bare minimum. flags and fileloc of yaml will have to be set after instantiation
// or be generated by new functions
func testNew() *cmd {
	ui := cli.NewMockUi()
	c := &cmd{
		UI: ui,
		config: commandhelper.NewTestClientConfig(),
	}
	c.flags = flag.NewFlagSet("", flag.ContinueOnError)
	c.flags.StringVar(&c.fileloc, "credfile-loc", "",
		"Location of yaml file containing creds to upload")
	return c
}

func Test_cmd_Run_Yaml(t *testing.T) {
	cmd := testNew()
	ctx := context.Background()
	cmd.fileloc = "./test-fixtures/uploadboth.yaml"
	expectedVcsCreds := &models.CredWrapper{
		Vcs: []*models.VCSCreds{
			{
				ClientId:     "fancy-frickin-identification",
				ClientSecret: "SHH-BE-QUIET-ITS-A-SECRET",
				TokenURL:     "https://ocelot.perf/site/oauth2/access_token",
				AcctName:     "lamb-shank",
				Type:         "bitbucket",
			},
		},
	}
	expectedRepoCreds := &models.RepoCredWrapper{
		Repo: []*models.RepoCreds{
			{
				Username:     "thisBeMyUserName",
				Password:     "SHH-BE-QUIET-ITS-A-SECRET",
				RepoUrl:      "https://ocelot.perf/nexus-yo",
				AcctName:     "jessishank",
				Type:         "nexus",
			},
		},
	}
	expectedCreds := &models.AllCredsWrapper{
		RepoCreds: expectedRepoCreds,
		VcsCreds: expectedVcsCreds,
	}
	var args []string
	if exit := cmd.Run(args); exit != 0 {
		t.Fatal("should return exit 0")
	}
	actualCreds, err := cmd.config.Client.GetAllCreds(ctx, &empty.Empty{})
	if err != nil {
		t.Fatal("could not get actual creds from fake guide ocelot client")
	}
	if !models.CompareAllCredWrappers(expectedCreds, actualCreds) {
		t.Error("expected creds mismatch\n expected: ", expectedCreds, "\n actual: ", actualCreds)
	}


}