syntax = "proto3";

package models;

import "google/protobuf/empty.proto";
import "google/api/annotations.proto";
import "google/protobuf/timestamp.proto";
import "protoc-gen-swagger/options/annotations.proto";
//import "google/protobuf/wrappers.proto"; //use this when you have to pass a string value

option (grpc.gateway.protoc_gen_swagger.options.openapiv2_swagger) = {
    info: {
        title: "Guide Ocelot Server";
        version: "1.0";
        contact: {
            name: "jessi shank";
            email: "jessishank@level11.com";
        };
    };
    schemes: HTTP;
    schemes: HTTPS;
    consumes: "application/json";
    produces: "application/json";

};
service GuideOcelot {
    rpc GetVCSCreds (google.protobuf.Empty) returns (CredWrapper) {
        option (google.api.http) = {
			get: "/v1/creds/vcs"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Returns all VCS creds that ocelot has and can use for checking out code to build.";
        };
    }

    rpc SetVCSCreds (VCSCreds) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/creds/vcs"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Add a new VCS credential configuration to ocelot for code checkout.";
        };
    }

    rpc CheckConn (google.protobuf.Empty) returns (google.protobuf.Empty) {}

    rpc SetVCSPrivateKey (SSHKeyWrapper) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/creds/vcs/ssh"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Attach the contents of an ssh file to a vcs account. This file will be attached to the build container for cloning the repository.";
        };
    }

    rpc GetRepoCreds (google.protobuf.Empty) returns (RepoCredWrapper) {
        option (google.api.http) = {
			get: "/v1/creds/repo"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Get all known repo integration credentials.";
        };
    }
    rpc SetRepoCreds (RepoCreds) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/creds/repo"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Add new repo credential. password, repoUrl, acctName, username and type are required. type must be nexus|docker.";
        };
    }

    rpc SetK8SCreds (K8SCreds) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/creds/k8s"
			body: "*"
		};
    }
    rpc GetK8SCreds (google.protobuf.Empty) returns (K8SCredsWrapper) {
        option (google.api.http) = {
			get: "/v1/creds/k8s"
		};
    }

    rpc GetAllCreds (google.protobuf.Empty) returns (AllCredsWrapper) {
        option (google.api.http) = {
			get: "/v1/creds"
		};
    }

    rpc BuildRuntime (BuildQuery) returns (Builds) {
        option (google.api.http) = {
			get: "/v1/buildruntime"
		};
    }
    rpc Logs (BuildQuery) returns (stream LineResponse) {}
    rpc LastFewSummaries (RepoAccount) returns (Summaries) {
        option (google.api.http) = {
			get: "/v1/summary"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "will return summaries of the builds for the corresponding repo/account. limit will set how many entries will be returned, will default to 5.";
        };
    }
    rpc GetStatus (StatusQuery) returns (Status) {
        option (google.api.http) = {
			get: "/v1/status"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "GetStatus will return the status of a specific build. Hierarchy for key to lookup with: if hash supplied, will only search by hash. If acctName and repoName are supplied and not hash, \nit will be used as a key for looking up status. If only partialRepo is given in the request, ocelot will attempt to find a match and return the latest build stage details for that.";
        };
    }
    rpc WatchRepo (RepoAccount) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/watch"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "watch will set up a webhook for the given repo/account. all fields required.";
        };
    }
    rpc BuildRepoAndHash (BuildReq) returns (stream LineResponse) {
        option (google.api.http) = {
			post: "/v1/build"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "build will attempt to trigger a build. If the git hash has already been built before, it can be triggered with just acctRepo and hash fields. If it has not been built before, the branch flag is required as well.";
        };
    }
    rpc PollRepo(PollRequest) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			post: "/v1/poll"
			body: "*"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "poll will set up a polling request. account, repo, cron, and branches are all required fields.";
        };
    }
    rpc DeletePollRepo(PollRequest) returns (google.protobuf.Empty) {
        option (google.api.http) = {
			delete: "/v1/poll"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "delete polling for a repo. account and repo are required.";
        };
    }
    rpc ListPolledRepos(google.protobuf.Empty) returns (Polls) {
        option (google.api.http) = {
			get: "/v1/poll"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "list all repositories that are being polled for changes";
        };
    }
    rpc FindWerker (BuildReq) returns (BuildRuntimeInfo) {
        // find a better place for this?
        option (google.api.http) = {
			get: "/v1/werker/loc"
		};
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "get network location of werker that is currrently ";
        };
    }
}

message BuildReq {
    // acctRepo is the ocelot account to which the creds are uploaded and the repository you wish to operate on, in the form account/repo
    string acctRepo = 1;
    // hash is the git hash to trigger.
    string hash = 2;
    // branch is the branch that corresponds to the git hash. if the git hash has never been built by ocelot, this field is required.
    string branch = 3;
}

message AllCredsWrapper {
    // All repository credentials for integrations
    RepoCredWrapper repoCreds = 1;
    // All VCS credentials for building
    CredWrapper vcsCreds = 3;
}

// just a container for a list of VCSCreds
message CredWrapper {
    repeated VCSCreds vcs = 2;
}

message SSHKeyWrapper {
    // account name to associate ssh key with
    string acctName = 1;
    // the contents of the private key
    bytes privateKey = 2;
    string type = 3;
}

message VCSCreds {
    // clientId is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.
    string clientId = 1;
    // clientSecret is generated by creating an oAuth consumer in bitbucket. it is required to generate tokens.
    string clientSecret = 2;
    // tokenUrl is the url at which to retrieve the token
    string tokenURL = 3;
    // acctName is the account to associate the VCSCred with. Must be the account name of the owner of the repository they wish to track (ie level11consulting)
    string acctName = 4;
    string type = 5;
    // just a string that says whether or not there is an ssh key on file
    string sshFileLoc = 6;
}

// container for list of repo creds
message RepoCredWrapper {
    repeated RepoCreds repo = 3;
}

message RepoCreds {
    // username of repository
    string username = 1;
    // password of repository
    string password = 2;
    map<string, string> repoUrl= 6;
    // account name (same as from vcs)
    string acctName = 4;
    // todo: should this be an enum?
    string type = 5;
    string projectName = 7;
}

message K8SCreds {
    string acctName = 1;
    // todo: should we also add option for multiple kubeconfigs? how would that be organized?
    string k8sContents = 2;
}

message K8SCredsWrapper {
    repeated K8SCreds K8SCreds = 2;
}

message StatusQuery {
    //hash is the git hash to get status of
    string hash = 1;
    //acctName is the corresponding account that the hash is attached to
    string acctName = 2;
    //repoName is the corresponding repo name that the hash is attached to
    string repoName = 3;
    //partialRepo is just the first n letters of repo
    string partialRepo = 4;
}

message BuildQuery {
    string hash = 1;
    int64 buildId = 2;
}

message Builds {
    map<string, BuildRuntimeInfo> builds = 1;
}

message BuildRuntimeInfo {
    bool   done     = 1;
    string ip       = 2;
    string grpcPort = 3;
    string hash = 4;
    string acctName = 5;
    string repoName = 6;
    string wsPort   = 7;
}

message LineResponse {
    string outputLine = 1;
}

message RepoAccount {
    string repo = 1;
    string account = 2;
    int32  limit = 3;
}

message Status {
    BuildSummary buildSum = 1;
    repeated Stage stages = 2;
    bool isInConsul       = 3;
}

message Stage {
    string stage = 1;
    string error = 2;
    int32 status = 3;
    repeated string messages = 4;
    google.protobuf.Timestamp startTime = 5;
    double stageDuration = 6;
}

message BuildSummary {
    string hash = 1;
    bool failed = 2;
    google.protobuf.Timestamp buildTime = 3;
    string account = 4;
    double buildDuration = 5;
    string repo = 6;
    string branch = 7;
    int64 buildId = 8;
    google.protobuf.Timestamp queueTime = 9;
}

message Summaries {
    repeated BuildSummary sums = 1;
}

message PollRequest {
    string account = 1;
    string repo = 2;
    string cron = 4;
    string branches = 5;
    google.protobuf.Timestamp lastCronTime = 6;
    map<string, string> lastHashes = 7;
}

message Polls {
    repeated PollRequest polls = 1;
}